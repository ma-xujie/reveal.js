
<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>reveal-md</title>
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/solarized.css" id="theme">
        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- If the query includes 'print-pdf', use the PDF print sheet -->
        <script>
          document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
        </script>
    </head>
    <body>

        <div class="reveal">
            <div class="slides"><section  data-markdown><script type="text/template">## 多线程与多进程编程

### Part I

<br>

#### 马栩杰

#### 电子系科协 软件部

mxj14@mails.tsinghua.edu.cn

</script></section><section ><section data-markdown><script type="text/template">
## 背景

- 现代操作系统都可以同时运行多个程序
  - IDE + 音乐播放器 + 浏览器 + 文本编辑器 + 邮箱客户端 + ....

- 很多软件单个程序也在同一时刻执行着很多任务
  - 浏览器：多个网页 + 下载
  - 一不小心中各种全家桶..
</script></section><section data-markdown><script type="text/template">
- 多个程序同时运行 = 多核处理器一个核心运行一个程序？
</script></section><section data-markdown><script type="text/template">
- 多个程序同时运行 $\neq$ 多核处理器一个核心运行一个程序

- 用多线程 & 多进程方式来同时执行多任务
</script></section></section><section ><section data-markdown><script type="text/template">
## 进程（Process）

- 程序是一段指示计算机每一步执行动作的指令序列
- 向操作系统发出执行一段程序的命令以后，程序被放入计算机内存运行，就产生了进程
</script></section><section data-markdown><script type="text/template">
## 进程（Process）

- 进程是计算机中运行程序的实体
- 一个程序至少产生一个进程，可以产生多个进程。
- 两个不同进程之间的变量所在的内存是相互独立的，指针（C/C++）和全局变量不能共享
- 一个进程需要系统分配 CPU 、内存、文件、I/O设备等资源以后才能工作
</script></section></section><section  data-markdown><script type="text/template">
## 线程（Thread）

- 线程指的是进程中一个单一顺序的控制流
- 一个进程中可以同时执行多个线程，每条线程并行执行不同的任务
- 线程被包含在进程之中，是进程中的实际运作单位
- 线程是操作系统能够进行运算调度的最小单位
- 每个线程都有独立的寄存器和栈空间
- 同一个进程内的各个线程共享虚拟地址，因此一个进程内的所有线程的内存是共享的
</script></section><section ><section data-markdown><script type="text/template">
## 多任务并行

- 操作系统中任何时候都有大量的程序同时执行
- 但是本质上 CPU 的一个核心在某一特定时刻只能执行一个任务
- 使用者往往感受不到大量同时运行的线程相互之间有什么影响
- 这是怎么做到的？
</script></section><section data-markdown><script type="text/template">
- 实际上操作系统的做法是__让 CPU 以很快的速度在不同的线程之间来回切换__
- 在一段时间内，可以做到每个线程都执行一小段时间
- 在使用者看来，就是在同时执行很多任务

![](./images/450px-Multithreaded_process.png)
</script></section></section><section ><section data-markdown><script type="text/template">
## 多进程与多线程编程

- 在写复杂程序的时候，同时执行多个任务是不可避免的
- 这时需要在程序中使用多进程/多线程编程。
- 需要在程序中同时进行多个任务的时候，一般有以下 3 种实现方式
  - 多进程
  - 多线程
  - 多进程 + 多线程
</script></section><section data-markdown><script type="text/template">
## 队式 17 为例

- 程序在运行时可能会需要同时运行 3D 界面、游戏逻辑、以及调用两个选手的程序，而其中每个模块都需要在一个独立的控制流下运行
</script></section><section data-markdown><script type="text/template">
- 进程1： 平台
  - 线程1： 平台主程序
  - 线程2： 逻辑
  - 线程3： 回放生成器
  - 线程4： 选手1
  - 线程5： 选手2
  - 线程6： socket 发送
  - 线程7： socket 接收
- 进程2： 3D 播放器
  - 线程8： 播放器主程序
  - 线程9： socket 收发
  - 线程10： Unreal 启动的各种线程
  - 线程11： ...
</script></section></section><section  data-markdown><script type="text/template">
## 多线程编程

- 可以看到，队式 17 的模块内部主要是以多线程的方式实现的
- 下面来看看多线程的实现
</script></section><section ><section data-markdown><script type="text/template">
## 简单的多线程程序


```python
import threading
def foo():
    print('Hello, world!')

t = threading.Thread(target=foo)  # 创建线程
t.start()  # 启动线程
# 然后就可以干别的事情了
```

- 以 Python 为例
- 在 Python 中启动多线程只需要 import 一下 threading 库，创建一个 Thread 对象，然后启动就可以啦
</script></section><section data-markdown><script type="text/template">

```python
threading.Thread(group=None, target=None, name=None,
                 args=(), kwargs={}, *, daemon=None)
```

- 来看看 Thread 的参数
- group 并没有什么卵用
- target 是 Thread 运行时调用的函数
- name 是给这个线程起的名字（一个字符串）
- args 是要传入 target 函数的所有参数（tuple）
- kwargs 是传入 target 的命名参数（dict）
- daemon 参数显式指定是否启动为守护线程，默认为否
</script></section><section data-markdown><script type="text/template">
## 一个例子

```python
import threading
import time

def foo():
    # 可以用 threading.current_thread() 获取当前所在的 Thread 对象
    print('This is thread %s.' % threading.current_thread().name)
    for i in range(5):
        print('hehe :-)')
    time.sleep(1)
    print('Thread %s end.' % threading.current_thread().name)
```

```python
t = threading.Thread(target=foo, name='hehe')
t.start()

print('This is thread %s.' % threading.current_thread().name)
print('haha :-D' % t.name)
print('Wait until %s end.' % t.name)

t.join()
print('This is thread %s.' % threading.current_thread().name)
```
</script></section><section data-markdown><script type="text/template">
## 结果

```
This is thread hehe.
hehe :-)
This is thread MainThread.
hehe :-)
haha :-D
hehe :-)
Wait until hehe end.
hehe :-)
hehe :-)
Thread hehe end.
This is thread MainThread.
```

- 可以看到在启动了线程 hehe 之后，主线程并没有中断运行，而是开始和 hehe “同时” 运行
- 当主线程调用 t.join() 时，开始挂起等待 hehe 运行结束
</script></section><section data-markdown><script type="text/template">
## Thread 类

```python
t = threading.Thread(target=foo)
t.start()  # 启动线程，只能调用一次
t.join()  # 阻塞当前所在的线程，等待 t 结束运行
```

- 对启动新线程的一种理解方式是从当前所在的控制流中分支出一条控制流
- join() 就表示在这个位置与分出去的控制流再合并为顺序执行的一个控制流

![](./images/forkjoin.png)
</script></section><section data-markdown><script type="text/template">
## Thread 类

- 如果不想永远等下去的话也可以在 join 中输入参数 `t.join(timeout=1)`
- 在这种情况下需要用 `t.is_alive()` 检查等待的线程是否真的在 timeout 内结束运行

- 无法直接获得 thread 所运行函数的返回值
- 需要采用其他的方法获得多线程运行的结果
</script></section></section><section  data-markdown><script type="text/template">
## 线程间内存共享

- 如果在程序中有一个所有函数都可以访问的全局变量的话，那么是不是就可以将函数的返回值写进全局变量中呢？
- 对于仅有一个线程写这个变量的情况下没错
- 在实践中，有时会出现多个线程同时要读写一个变量的状况，这时候多个线程的操作会发生冲突
- 当多个线程同时尝试修改一块内存值的时候，由于线程间切换的问题，可能会导致数据不正确（见讲义）
</script></section><section ><section data-markdown><script type="text/template">
## 互斥锁（Mutex）

- 互斥锁是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成（摘自维基百科）
</script></section><section data-markdown><script type="text/template">
## 互斥锁

```python
cnt = 0
mutex = threading.Lock()  # 创建锁

def foo():
    global cnt
    for i in range(100000):
        mutex.acquire()  # 获取锁
        try:
            cnt = cnt + 1
        finally:
            mutex.release() # 释放锁
```

- 互斥锁可以保证一个线程执行一段代码时不会有其他线程同时执行同一段代码
- 一个线程尝试运行带有互斥锁的代码段时，如果没有其他线程获得这个锁，那么这个线程就可以获得锁，并进入该段代码
- 否则，这个线程会暂停运行，直到该段代码的锁被释放
</script></section><section data-markdown><script type="text/template">
## 互斥锁

```python
cnt = 0
mutex = threading.Lock()

def foo():
    global cnt
    for i in range(100000):
      with mutex:
        cnt = cnt + 1
```

- 用 with 语句来写更加优雅
</script></section><section data-markdown><script type="text/template">
## 互斥锁

- 如果有两个线程都持有锁，并且互相希望访问对方加锁的代码块的话，就会出现死锁的情况
- 在这种情况下，如果没有外力干预，这两个线程就会永远暂停运行
- 需要避免出现这种情况
</script></section><section data-markdown><script type="text/template">
## 互斥锁

- 如果希望一段代码可以同时被多个线程访问，但是又想限制访问的线程数量的话，可以使用信号量 （Semaphore） 来限制同时访问一段代码的总线程数
</script></section></section><section ><section data-markdown><script type="text/template">
## 线程安全队列

- 队列（Queue）是一种非常好的多线程同步机制
- Python 提供的 Queue 是线程安全的队列
- 使用 Python Queue 不用考虑会出现数据被多线程改错的问题
- 不用自己再加锁
</script></section><section data-markdown><script type="text/template">
## 线程安全队列

```python
import queue
import random
import threading
import time

q = queue.Queue()
```

```python
def foo():
    time.sleep(random.random())
    # 向队列里放东西
    q.put('Hello! %s' % threading.current_thread().name)

for i in range(10):
    t = threading.Thread(target=foo)
    t.start()

for i in range(10):
    s = q.get()  # 从队列中取东西
    print(s)
```

- 如果在队列为空的时候尝试调用 `get()` 的话，当前线程会暂停运行，一直等到队列非空 get 到东西为止
</script></section></section><section ><section data-markdown><script type="text/template">
## 多核处理器

- 一个线程是一个线性的控制流
- 在多核处理器上，我们可以让每个线程在一个独立的核心上运行
- 在 N 核处理器上的多线程任务就可以用单线程执行的 1/N 的时间完成（如果线程够多）？
</script></section><section data-markdown><script type="text/template">
## 多核处理器

- 对绝大多数常见的语言而言，这个认识是正确的
- 然而，对 Python 来说，在多核处理器上运行一个多线程程序却往往不能达到预期的性能提升
</script></section><section data-markdown><script type="text/template">
## GIL

- 在 Python 的 CPython 实现中，引入了全局锁 GIL

> In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.
</script></section><section data-markdown><script type="text/template">
## GIL

- GIL 的存在使得 Python 的代码在同一时刻只能被同一个进程内的一个线程执行在性能上强行将程序变成单线程，限制了 Python 多线程的效率
- 实际上在运行中，一个 Python 程序的所有线程加起来也只能使用总计一个 CPU 核的计算资源
</script></section></section><section ><section data-markdown><script type="text/template">
## C++ 多线程

- C++ 11 的 STL 中也提供了多线程编程接口
</script></section><section data-markdown><script type="text/template">
## C++ 多线程

```cpp
void foo(string str) {
    cout << str << endl;
}

int main() {
    // 创建线程对象的同时即开始运行
    std::thread t(foo, "Hello, world!");

    // Do something else

    t.join();  // 等待线程结束
}
```

- 头文件 `#include<thread>`
- C++ 的多线程是真正的多线程
- 在多核 CPU 上运行的多线程 C++ 程序可以充分利用计算机资源
</script></section><section data-markdown><script type="text/template">
## C++ 多线程

```cpp
std::mutex mtx;
mtx.lock();
// Do something
mtx.unlock();
```
- 互斥锁头文件 `#include<mutex>`
</script></section><section data-markdown><script type="text/template">
## C++ 多线程

- C++ 的 queue 并不是线程安全的
- 如果想用 queue 来进行线程间同步的话需要手动对改变 queue 内容的操作加锁
</script></section></section><section ><section data-markdown><script type="text/template">
## 作业

### 完成一个非常简单的多线程爬虫

- 一个获取豆瓣电影相关推荐的小程序
- 单线程的代码已经写好
- 把代码改为多线程实现
- 提交到邮箱（见讲义）
- （看代码）
</script></section><section data-markdown><script type="text/template">
## 作业提示

- 可以开若干个线程，让每个线程自行去队列中领取任务并执行
- 注意 Python 的 list 不是线程安全的。

</script></section></section><section  data-markdown><script type="text/template">
## 下一讲

- 多进程编程
- 进程间通信
- 跨语言通信

</script></section></div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
              { src: 'plugin/math/math.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default',
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {};
            options = extend(defaultOptions, options, queryOptions);
            Reveal.initialize(options);
        </script>

          <script src="/scripts/reveal.js"></script>
    </body>
</html>
