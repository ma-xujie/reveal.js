
<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>reveal-md</title>
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/solarized.css" id="theme">
        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- If the query includes 'print-pdf', use the PDF print sheet -->
        <script>
          document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
        </script>
    </head>
    <body>

        <div class="reveal">
            <div class="slides"><section  data-markdown><script type="text/template">## 多线程与多进程编程

### Part II

<br>

#### 马栩杰

#### 电子系科协 软件部
</script></section><section ><section data-markdown><script type="text/template">
## 回顾
</script></section><section data-markdown><script type="text/template">
## 进程（Process）

- 一个程序至少产生一个进程，可以产生多个进程。
- 两个不同进程之间的变量所在的内存是相互独立的，指针（C/C++）和全局变量不能共享
</script></section><section data-markdown><script type="text/template">
## 线程（Thread）

- 线程是进程中一个单一顺序的控制流
- 一个进程中可以同时执行多个线程，每条线程并行执行不同的任务
- 同一个进程内的各个线程共享虚拟地址，因此一个进程内的所有线程的内存是共享的
</script></section></section><section ><section data-markdown><script type="text/template">
## 多进程编程

```python
import multiprocessing

# 定义 foo

p = multiprocessing.Process(target=foo， name='hehe')
p.start()
# 做别的事情
p.join()
```

- 在 Python 中，多进程的使用也非常容易
- 接口与 Thread 几乎一致
</script></section><section data-markdown><script type="text/template">
## Python 的多进程编程

- Python 的多进程运行不受 GIL 的限制
- 多进程之间传递数据可以使用 `multiprocessing.Queue`
- `multiprocessing.Queue` 与 `queue.Queue` 接口一致
- `queue.Queue` 不能在多进程中正常工作（？）
</script></section><section data-markdown><script type="text/template">
## 进程池

- 启动新进程的时间和内存开销要远远大于启动新线程
- 在 Python 中如果需要让大量独立的进程并行执行很多任务的话，可以考虑使用进程池（`multiprocessing.Pool`）实现
</script></section></section><section ><section data-markdown><script type="text/template">
## C++ 多进程

- C++ 标准库不支持多进程编程。
- 在 \*nix 系统中，可以使用 unistd.h 中的 fork 来创建新的进程。
</script></section><section data-markdown><script type="text/template">
## C++ 多进程

```cpp
#include <stdio.h>
#include <unistd.h>

int main() {
  printf("Hello!\n");
  pid_t pid = fork();
  printf("%d\n", pid);
  if (pid == 0) {
    printf("I'm child process.\n");
  } else {
    printf("I'm main process, child pid = %d.\n", pid);
  }
}
```

- 使用fork 创建了一个新的进程。
</script></section><section data-markdown><script type="text/template">
## fork

- 调用 fork 时，会在 fork 处复制当前的进程，产生一个子进程
- fork 的返回值对两个进程不同
  - 父进程中返回子进程的 pid
  - 子进程中返回 0
- 父进程和子进程同时在 fork 后继续运行
- 此时，父进程和子进程的堆栈中的数据内容是相同的
- 此后两个进程对变量的修改互相不会产生影响
</script></section><section data-markdown><script type="text/template">
## fork

![](./images/forkjoin.png)
</script></section><section data-markdown><script type="text/template">
## fork

- 通常在 fork 后需要两个进程做不同的工作
- \*nix 提供了一系列 exec 函数，让一个进程可以切换到另一项工作
- 在 Windows 中， `windows.h`，`CreateProcess`
</script></section></section><section ><section data-markdown><script type="text/template">
## 多线程与多进程的比较

- 多线程
  - 共享内存地址，线程间交换数据容易
  - 同步需要考虑线程安全问题
  - 创建、销毁时的开销较小
  - 运行时占用资源小
  - 一个线程挂掉会导致整个进程挂掉
  - （CPython）受 GIL 的限制
</script></section><section data-markdown><script type="text/template">
## 多线程与多进程的比较

- 多进程
  - 内存地址分离，进程间交换数据困难
  - 数据相对独立，一般不用担心安全性
  - 创建、销毁时的开销较大
  - 运行时占用资源大
  - 多个进程相对独立
  - （CPython）不受 GIL 限制
</script></section><section data-markdown><script type="text/template">
## 多线程与多进程的比较

- 优先选择多线程编程（通常情况下）
  - IO 密集
  - 多任务计算量大
  - 任务间切换频繁
  - 大量创建和销毁子任务
- 选择多进程（通常）
  - 多个任务之间的相关性较弱
  - 多机分布计算需求
  - Python 并行进行大量计算（GIL）
</script></section></section><section ><section data-markdown><script type="text/template">
## 进程间通信与跨语言通信

- 进程间通信（IPC）指至少两个进程或线程间传送数据或信号的一些技术或方法
</script></section><section data-markdown><script type="text/template">
## 队式 17 为例

- 进程1： 平台
  - 线程1： 平台主程序
  - 线程2： 逻辑
  - 线程3： 回放生成器
  - 线程4： 选手1
  - 线程5： 选手2
  - 线程6： socket 发送
  - 线程7： socket 接收
- 进程2： 3D 播放器
  - 线程8： 播放器主程序
  - 线程9： socket 收发
  - 线程10： Unreal 启动的各种线程
  - 线程11： ...
</script></section><section data-markdown><script type="text/template">
## 队式 17 为例

- 选手程序被编译成了 dll，这一部分被合并到平台进程中，简化了选手和平台通信的过程
- 实际实现中，采用了 Python ctypes 库提供的封装回调函数的办法，让选手的 C++ 程序可以在 C 线程内直接调用 Python 中实现的通信函数
- Python 中通信函数使用队列来实现，每个选手的线程可以向队列中放入指令，由平台主线程拿出来处理

- 3D 播放器使用虚幻引擎制作生成
- 播放器和平台的两个进程之间通过 Socket 传递数据
</script></section></section><section ><section data-markdown><script type="text/template">
## TCP/IP

- TCP/IP 协议
- 接入互联网的每台计算机有惟一的 IP 地址
- 同一计算机上不同的程序和功能在收发信息时使用不同端口进行区分
</script></section><section data-markdown><script type="text/template">
## Socket 通信

- Socket 是一种常用的网络中进程通信的工具
- 指定
    - IP地址
    - 协议
    - 端口
- 就可以实现网络中两个进程的点对点通信
- 当然也可以实现本机的进程间通信
</script></section><section data-markdown><script type="text/template">
## Socket 通信 - 服务器端

```python
# 指定协议为 ipv4, TCP
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 绑定到本机（127.0.0.1）的 6666 端口（端口可以自行指定）
s.bind(('127.0.0.1', 6666))
```

```python
# 开始监听
backlog = 1  # 指定最大的连接数量
s.listen(backlog)
print('Waiting for connection.')

# 接收一个新的连接
sock, addr = s.accept()

# 创建一个新的线程处理连接
t = threading.Thread(target=socket_link, args=(sock, addr))
t.start()
```

- `import socket, threading`
</script></section><section data-markdown><script type="text/template">
## Socket 通信 - 服务器端

```python
def socket_link(sock, addr):
    print('Accept connection from %s:%s' % addr)
    try:
        sock.send(b'Hello!')  # 服务端和客户端都可以收发数据
        while True:
            msg = sock.recv(4096)  # 接收信息
            if(len(msg) > 0):
                print(msg.decode('ascii'))
            else:  # 没有收到消息就断开连接
                break
    finally:
        sock.close()  # 要保证在使用后关闭 Socket
```
</script></section><section data-markdown><script type="text/template">
## Socket 通信 - 客户端

```python
addr = ('127.0.0.1', 6666)   # 与 server 相同
s = socket.socket()

s.connect(addr)  # 如果此时连接失败会抛出异常
```

```python
try:
    msg_get = s.recv(4096)
    print(msg_get.decode('ascii'))
    for i in range(10):
        msg = b'hehe'
        s.send(msg)
        print('Message to %s:%s : %s' % (*addr, msg.decode('ascii')))
        time.sleep(1)
finally:
    s.close()  # 要保证在使用后关闭 Socket，否则该端口会一直被占用
```
</script></section><section data-markdown><script type="text/template">
## Socket 通信

![](./images/48.png)
</script></section><section data-markdown><script type="text/template">
## Socket 通信

- 为了保证正确接收每一条数据，发送端在发送的时候应该主动标记每条信息的起止
- recv 指定的 buffer 大小小于实际接收到的字符数量，剩下字符留在缓冲区中，可以下次再接收
</script></section><section data-markdown><script type="text/template">
## C++ 中的 Socket

- 在标准 C++ 中，Socket 的实现是平台相关的
- 实现比 Python 复杂（要用的时候在网上现抄代码..）
- Windows： winsock
- \*nix： Linux Socket 相关内容。
</script></section></section><section ><section data-markdown><script type="text/template">
## JSON

- 几乎所有语言都支持 Socket
- 只要能在收发端将数据转换为字符串
- 就可以在任意语言实现的多个进程之间传递任何数据
- 一种常用的纯文本数据格式是 JSON
</script></section><section data-markdown><script type="text/template">
## JSON

```JSON
{
     "firstName": "John",
     "lastName": "Smith",
     "sex": "male",
     "age": 25,
     "address":
     {
         "streetAddress": "21 2nd Street",
         "city": "New York",
         "state": "NY",
         "postalCode": "10021"
     }
 }
 ```
</script></section><section data-markdown><script type="text/template">
## JSON

- 在 Python 中只需要使用模块 `json`
- 然后调用 `json.dumps` 和 `json.loads`
- 实现 Python 数据结构与 JSON 字符串之间的转换
- 其他语言也有很多 JSON 相关的轮子可用
</script></section></section><section ><section data-markdown><script type="text/template">
## 作业-Socket

- 自行查 & 抄 & 改代码
- 编译对应自己平台的 C++ Socket Server（实际上是 C..）
- 用示例代码中的 Python Socket Client 与之建立连接
- 作业不收，成功接收到数据就好
</script></section><section data-markdown><script type="text/template">
## 作业-跨语言协作（选做）

- 通过 Socket 通信
- 在 Python 中向 C++ 程序发出计算斐波那契数列的请求
- C++ 程序收到后完成计算并通过 Socket 返回生成的数列
- 在 Python 中转换为 int 型 list
- 当然还是不收...
</script></section></section><section  data-markdown><script type="text/template">
## 下期预告

- 软件测试
</script></section></div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
              { src: 'plugin/math/math.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default',
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {};
            options = extend(defaultOptions, options, queryOptions);
            Reveal.initialize(options);
        </script>
        
          <script src="/scripts/slides"></script>
    </body>
</html>

